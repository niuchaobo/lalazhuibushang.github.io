<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java.util.ConcurrentModificationException异常排查</title>
    <url>/2019/09/27/java.util.ConcurrentModificationException%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<p>&emsp;&emsp;java.util.ConcurrentModificationException对于这个异常我们一般会认为是在遍历list的时候对这个list做了add,remove等修改操作造成的，最近在线上日志偶尔发现了这个异常，完整异常如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.util.ConcurrentModificationException: null</span><br><span class="line">	at java.util.ArrayList.sort(ArrayList.java:1462)</span><br><span class="line">	at java.util.Collections.sort(Collections.java:175)</span><br><span class="line">	at com.xxx.xxx.xxx.xxx(xxx.java:17)注:这是业务代码所以用‘xxx’代替了</span><br><span class="line">	at com.xxx.xxx.xxx.xxx(xxx.java:65)</span><br><span class="line">	at sun.reflect.GeneratedMethodAccessor237.invoke(Unknown Source)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)</span><br><span class="line">	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:963)</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897)</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>代码如下：（原有代码比较复杂，写个类似demo代替）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CmeTest &#123;</span><br><span class="line">	private static Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		buildMap();</span><br><span class="line">		Runnable run = new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Collections.sort(map.get(&quot;a&quot;));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(10);</span><br><span class="line">		for(int i=0 ;i&lt;1000;i++) &#123;</span><br><span class="line">			pool.execute(run);</span><br><span class="line">		&#125;</span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void buildMap() &#123;</span><br><span class="line">		List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">		list1.add(1);</span><br><span class="line">		list1.add(2);</span><br><span class="line">		list1.add(3);</span><br><span class="line">		map.put(&quot;a&quot;, list1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>代码的主要逻辑就是并发地对一个list进行排序。查看Collections.sort()的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1    @Override</span><br><span class="line">2    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">3    public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">4        final int expectedModCount = modCount;</span><br><span class="line">5        Arrays.sort((E[]) elementData, 0, size, c);</span><br><span class="line">6        if (modCount != expectedModCount) &#123;</span><br><span class="line">7            throw new ConcurrentModificationException();</span><br><span class="line">8        &#125;</span><br><span class="line">9        modCount++;</span><br><span class="line">10    &#125;</span><br></pre></td></tr></table></figure>

<p>重点看第6，10行，当第一个线程排序完成，执行完第9行时第二个线程正好执行到第6行，这时候就会抛出ConcurrentModificationException，所以对于全局的list,做并发排序的时候需要额外注意一下。解决方法有两个：<br>1.加锁<br>2.创建新的list,再将全局list的数据addAll到新list中，对新list排序</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用bitset实现毫秒级查询（二）</title>
    <url>/2019/09/27/%E4%BD%BF%E7%94%A8bitset%E5%AE%9E%E7%8E%B0%E6%AF%AB%E7%A7%92%E7%BA%A7%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>在<a href="http://www.cnblogs.com/ncbest/p/7703615.html" target="_blank" rel="noopener">上一篇</a>中我们了解了bitset索引的基本用法，本篇开始学习bitset索引更新及一些复杂查询。</p>
<h5 id="1-bitset索引更新"><a href="#1-bitset索引更新" class="headerlink" title="1.bitset索引更新"></a>1.bitset索引更新</h5><p>&emsp;&emsp;因为我们的数据是在系统启动时全部加载进内存，所以当数据库数据发生变化时要实时通知到内存，可以使用消息队列的方式实现：将新增或者修改的数据写入kafka,然后在索引服务中从kafka中读出数据更新索引.<br>在UserIndexStore类中增加更新索引方法：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * 更新索引</span><br><span class="line">	 * @param user</span><br><span class="line">	 */</span><br><span class="line">	public void updateIndex(User user) &#123;</span><br><span class="line">		String name = user.getName();</span><br><span class="line">		Integer userIndex = this.nameIndexMap.get(name);</span><br><span class="line">		if (userIndex != null) &#123;</span><br><span class="line">			clear(userIndex);//清除bitset对应位置的值</span><br><span class="line">			update(user, userIndex);</span><br><span class="line">			this.userMap.put(userIndex, user);</span><br><span class="line">			this.nameIndexMap.put(user.getName(), userIndex);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			//新增时会有并发问题</span><br><span class="line">			synchronized (this) &#123;</span><br><span class="line">				int index = this.userMap.size() + 1;</span><br><span class="line">				createIndex(user, index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void update(User user, Integer userIndex) &#123;</span><br><span class="line">		getAddress().update(user.getAddress(), userIndex);</span><br><span class="line">		getAge().update(user.getAge(), userIndex);</span><br><span class="line">		getGender().update(user.getGender(), userIndex);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void clear(Integer index) &#123;</span><br><span class="line">		getAddress().clear(index);</span><br><span class="line">		getAge().clear(index);</span><br><span class="line">		getGender().clear(index);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在BitSetIndexModel类中增加clear()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   /**</span><br><span class="line"> * 对第i位置0</span><br><span class="line"> * @param i</span><br><span class="line"> */</span><br><span class="line">public void clear(Integer i) &#123;</span><br><span class="line">	for (BitSet bs : bsList) &#123;</span><br><span class="line">		if (bs != null &amp;&amp; i &lt; bs.length()) &#123;</span><br><span class="line">			bs.clear(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-bitset进阶查询"><a href="#2-bitset进阶查询" class="headerlink" title="2.bitset进阶查询"></a>2.bitset进阶查询</h5><p> ‘&gt;=’，’&lt;=’，between and<br>在BitSetIndexModel类中增加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;String&gt; getHigherList(String str) &#123;</span><br><span class="line">		List&lt;String&gt; newlist = new ArrayList&lt;String&gt;();</span><br><span class="line">		newlist.add(str);</span><br><span class="line">		newlist.addAll(list);</span><br><span class="line">		// 排序</span><br><span class="line">		Collections.sort(newlist);</span><br><span class="line">		// 查找str在list中的位置</span><br><span class="line">		int fromIndex = Collections.binarySearch(newlist, str);</span><br><span class="line">		if (fromIndex &gt;= 0) &#123;</span><br><span class="line">			// 如果map中不包含当前值则 index后移一位</span><br><span class="line">			if (map.get(str) == null) &#123;</span><br><span class="line">				fromIndex++;</span><br><span class="line">			&#125;</span><br><span class="line">			return newlist.subList(fromIndex, newlist.size());</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return new ArrayList&lt;String&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public List&lt;String&gt; getLowerList(String str) &#123;</span><br><span class="line">		List&lt;String&gt; newlist = new ArrayList&lt;String&gt;();</span><br><span class="line">		newlist.add(str);</span><br><span class="line">		newlist.addAll(list);</span><br><span class="line">		// 排序</span><br><span class="line">		Collections.sort(newlist);</span><br><span class="line">		// 查找str在list中的位置</span><br><span class="line">		int endIndex = Collections.binarySearch(newlist, str);</span><br><span class="line">		if (endIndex &gt;= 0) &#123;</span><br><span class="line">			return newlist.subList(0, endIndex + 1);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return new ArrayList&lt;String&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	public &lt;T extends Comparable&lt;? super T&gt;&gt; List&lt;T&gt; getRange(T min, T max, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">		List&lt;T&gt; newlist = new ArrayList&lt;T&gt;();</span><br><span class="line">		for (String s : list) &#123;</span><br><span class="line">			newlist.add((T) (s));</span><br><span class="line">		&#125;</span><br><span class="line">		Collections.sort(newlist);</span><br><span class="line">		// 查找str在list中的位置</span><br><span class="line">		int fromIndex = minBinarySearch(newlist, min, c);</span><br><span class="line">		int endIndex = maxBinarySearch(newlist, max, c);</span><br><span class="line">		if (fromIndex &gt;= 0 &amp;&amp; endIndex &lt;= list.size() - 1) &#123;</span><br><span class="line">			if (fromIndex == endIndex) &#123;</span><br><span class="line">				return newlist.subList(fromIndex, endIndex + 1);</span><br><span class="line">			&#125;</span><br><span class="line">			return newlist.subList(fromIndex, ++endIndex);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return new ArrayList&lt;T&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 *</span><br><span class="line">	 * @param list</span><br><span class="line">	 * @param key</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	private static &lt;T&gt; int maxBinarySearch(List&lt;T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">		int low = 0;</span><br><span class="line">		int high = list.size() - 1;</span><br><span class="line">		int mid = 0;</span><br><span class="line">		while (low &lt;= high) &#123;</span><br><span class="line">			mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">			T midVal = list.get(mid);</span><br><span class="line">			int cmp = c.compare(midVal, key);</span><br><span class="line">			if (cmp &lt; 0) &#123;</span><br><span class="line">				low = mid + 1;</span><br><span class="line">			&#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">				high = mid - 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return mid; // key found</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (mid == low) &#123;</span><br><span class="line">			return high;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static &lt;T&gt; int minBinarySearch(List&lt;T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">		int low = 0;</span><br><span class="line">		int high = list.size() - 1;</span><br><span class="line">		int mid = 0;</span><br><span class="line">		while (low &lt;= high) &#123;</span><br><span class="line">			mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">			T midVal = list.get(mid);</span><br><span class="line">			int cmp = c.compare(midVal, key);</span><br><span class="line">			if (cmp &lt; 0) &#123;</span><br><span class="line">				low = mid + 1;</span><br><span class="line">			&#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">				high = mid - 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return mid; // key found</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (high == mid) &#123;</span><br><span class="line">			return low;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在UserIndexStore中增加以下方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * 查询年龄大于等于指定值的user索引</span><br><span class="line">	 * @param age</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public BitSet findUserByAgeHigher(String age) &#123;</span><br><span class="line">		BitSetIndexModel indexModel = getAge();</span><br><span class="line">		List&lt;String&gt; strs = indexModel.getHigherList(age);</span><br><span class="line">		BitSet bitset = null;</span><br><span class="line">		for (String str : strs) &#123;</span><br><span class="line">			bitset = indexModel.or(str, bitset);</span><br><span class="line">		&#125;</span><br><span class="line">		return bitset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 查询age小于等于指定值的user索引</span><br><span class="line">	 * @param age</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public BitSet findUserByAgeLower(String age) &#123;</span><br><span class="line">		BitSetIndexModel indexModel = getAge();</span><br><span class="line">		List&lt;String&gt; strs = indexModel.getLowerList(age);</span><br><span class="line">		BitSet bitset = null;</span><br><span class="line">		for (String str : strs) &#123;</span><br><span class="line">			bitset = indexModel.or(str, bitset);</span><br><span class="line">		&#125;</span><br><span class="line">		return bitset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 查询age在某两个值区间内的user索引</span><br><span class="line">	 * @param min</span><br><span class="line">	 * @param max</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public BitSet findUserByAgeBetweenAnd(String min, String max) &#123;</span><br><span class="line">		BitSetIndexModel indexModel = getAge();</span><br><span class="line">		List&lt;String&gt; strs = indexModel.getRange(min, max, new Comparator&lt;Object&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public int compare(Object o1, Object o2) &#123;</span><br><span class="line"></span><br><span class="line">				return Integer.valueOf(o1 == null ? &quot;0&quot; : o1.toString()).compareTo(Integer.valueOf(o2 == null ? &quot;0&quot; : o2.toString()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		BitSet bitset = null;</span><br><span class="line">		for (String str : strs) &#123;</span><br><span class="line">			bitset = indexModel.or(str, bitset);</span><br><span class="line">		&#125;</span><br><span class="line">		return bitset;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试，查询年龄在16-17之间的北京女孩。"><a href="#测试，查询年龄在16-17之间的北京女孩。" class="headerlink" title="测试，查询年龄在16-17之间的北京女孩。"></a>测试，查询年龄在16-17之间的北京女孩。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BitSetTestRange &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;User&gt; users = buildData();</span><br><span class="line">		UserIndexStore.getInstance().createIndex(users);</span><br><span class="line">		ExecutorService executorService = Executors.newFixedThreadPool(50);</span><br><span class="line">		int num = 2000;</span><br><span class="line">		long begin1 = System.currentTimeMillis();</span><br><span class="line">		for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">			Runnable syncRunnable = new Runnable() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					BitSet bs = UserIndexStore.getInstance().query(&quot;北京&quot;, &quot;girl&quot;, null);</span><br><span class="line">					BitSet ageBs = UserIndexStore.getInstance().findUserByAgeBetweenAnd(&quot;16&quot;, &quot;17&quot;);</span><br><span class="line">					bs.and(ageBs);</span><br><span class="line">					for (Integer index : BitSetIndexModel.getRealIndexs(bs)) &#123;</span><br><span class="line">						UserIndexStore.getInstance().findUser(index);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			executorService.execute(syncRunnable);</span><br><span class="line">		&#125;</span><br><span class="line">		executorService.shutdown();</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (executorService.awaitTermination(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">					System.err.println(&quot;单次查询时间为：&quot; + (System.currentTimeMillis() - begin1) / num + &quot;ms&quot;);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static List&lt;User&gt; buildData() &#123;</span><br><span class="line">		String[] addresss = &#123; &quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot; &#125;;</span><br><span class="line">		String[] ages = &#123; &quot;16&quot;, &quot;17&quot;, &quot;18&quot; &#125;;</span><br><span class="line">		List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">		for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">			User user = new User();</span><br><span class="line">			user.setName(&quot;name&quot; + i);</span><br><span class="line">			int rand = ThreadLocalRandom.current().nextInt(3);</span><br><span class="line">			user.setAddress(addresss[ThreadLocalRandom.current().nextInt(3)]);</span><br><span class="line">			user.setGender((rand &amp; 1) == 0 ? &quot;girl&quot; : &quot;boy&quot;);</span><br><span class="line">			user.setAge(ages[ThreadLocalRandom.current().nextInt(3)]);</span><br><span class="line">			users.add(user);</span><br><span class="line">		&#125;</span><br><span class="line">		return users;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单次查询时间为：22ms</span><br></pre></td></tr></table></figure>

<p>相比”=”查询，区间查询速度慢了一些，但还在预期之内。</p>
<hr>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>&emsp;&emsp;以上就实现了一个bitset索引，支持索引创建，更新，查询。并且因为没有传统的网络传输和磁盘io,所以速度非常快，基本上响应时间都在10ms以内。如果需要我可以在下一篇使用spring cloud搭建一个较完整的demo，供大家参考使用。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用bitset实现毫秒级查询</title>
    <url>/2019/09/27/%E4%BD%BF%E7%94%A8bitset%E5%AE%9E%E7%8E%B0%E6%AF%AB%E7%A7%92%E7%BA%A7%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>因为业务要求api的一次请求响应时间在10ms以内，所以传统的数据库查询操作直接被排除(网络io和磁盘io)。通过调研，最终使用了bitset,目前已经正常运行了很久</p>
<hr>
<h5 id="bitset介绍"><a href="#bitset介绍" class="headerlink" title="bitset介绍"></a>bitset介绍</h5><p>看JDK中的解释简直一头雾水，用我自己的理解概括一下</p>
<ol>
<li>bitset的内部实现是long数组</li>
<li>set中每一个位的默认值为false（0）</li>
<li>bitset长度按需增长</li>
<li>bitset非线程安全</li>
</ol>
<hr>
<a id="more"></a>
<h5 id="bitset关键方法分析"><a href="#bitset关键方法分析" class="headerlink" title="bitset关键方法分析"></a>bitset关键方法分析</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sets the bit at the specified index to &#123;@code true&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param  bitIndex a bit index</span><br><span class="line"> * @throws IndexOutOfBoundsException if the specified index is negative</span><br><span class="line"> * @since  JDK1.0</span><br><span class="line"> */</span><br><span class="line">public void set(int bitIndex) &#123;</span><br><span class="line">    if (bitIndex &lt; 0)</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);</span><br><span class="line"></span><br><span class="line">    int wordIndex = wordIndex(bitIndex);</span><br><span class="line">    expandTo(wordIndex);</span><br><span class="line"></span><br><span class="line">    words[wordIndex] |= (1L &lt;&lt; bitIndex); // Restores invariants</span><br><span class="line"></span><br><span class="line">    checkInvariants();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置指定“位”为true，bitIndex参数为非负整数。假设我们执行以下代码,观察上面代码中worIndex，words[wordIndex]值的变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BitSet bs = new BitSet()</span><br><span class="line">bs.set(0);</span><br><span class="line">bs.set(1);</span><br><span class="line">bs.set(2);</span><br><span class="line">bs.set(3);</span><br><span class="line">bs.set(4);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>bitIndex</th>
<th>wordIndex</th>
<th>words[wordIndex]</th>
<th>words[wordIndex]二进制表示</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>3</td>
<td>0011</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>7</td>
<td>0111</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>15</td>
<td>1111</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>31</td>
<td>0001 1111</td>
</tr>
<tr>
<td>通过上表，我们可以很清晰的根据bitIndex和words[wordIndex]二进制值的对应关系，得到一个结论，即：bitset中每一个long可以表示64个非负整数在bitSet中存在与否。例如：0001可以表示整数0在bitset中存在，1111可以表示整数3,2,1,0在bitset中存在。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>***</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="进入正题，实现bitset毫秒级查询"><a href="#进入正题，实现bitset毫秒级查询" class="headerlink" title="进入正题，实现bitset毫秒级查询"></a>进入正题，实现bitset毫秒级查询</h4><p>想象一个场景，我们有一张user表,name唯一。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) NOT NULL,</span><br><span class="line">  `address` varchar(255) NOT NULL comment &apos;地址&apos;,</span><br><span class="line">  `gender` varchar(10) NOT NULL comment &apos;性别&apos;,</span><br><span class="line">  `age` varchar(10) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)，</span><br><span class="line">  UNIQUE KEY `name` (`name`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>假设我们要查询“北京市18岁的女生”，那么对应的sql如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from `user` where address=&apos;北京&apos; and age=&apos;18&apos; and gender=&apos;girl&apos;;</span><br></pre></td></tr></table></figure>

<p>如何使用bitset实现同样的查询呢？</p>
<ol>
<li>将user表数据加载进内存中</li>
<li>为user表建立address,age,gender维度的bitset索引</li>
<li>根据索引查询数据</li>
</ol>
<h5 id="1-将user表数据加载进内存中"><a href="#1-将user表数据加载进内存中" class="headerlink" title="1.将user表数据加载进内存中"></a>1.将user表数据加载进内存中</h5><p>将user表从数据库读取出来存入List</p>
<p>User实体类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Cloneable &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private String address;</span><br><span class="line">	private String gender;</span><br><span class="line">	private String age;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;User [name=&quot; + name + &quot;, address=&quot; + address + &quot;, gender=&quot; + gender + &quot;, age=&quot; + age + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public User clone() &#123;</span><br><span class="line">		User user = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			user = (User) super.clone();</span><br><span class="line">		&#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return user;</span><br><span class="line">	&#125;</span><br><span class="line">    //省略get set 方法。。。</span><br></pre></td></tr></table></figure>

<h5 id="2-建立索引"><a href="#2-建立索引" class="headerlink" title="2.建立索引"></a>2.建立索引</h5><p>创建bitset索引模型类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BitSetIndexModel &#123;</span><br><span class="line">	private String type;//索引类型：address，age，gender</span><br><span class="line">	private ConcurrentHashMap&lt;String, Integer&gt; map;//索引类型和bitSet在bsList中下标的映射关系</span><br><span class="line">	private List&lt;String&gt; list;//索引类型的值集合，例如gender：girl，boy</span><br><span class="line">	private List&lt;BitSet&gt; bsList;//bitset集合</span><br><span class="line"></span><br><span class="line">	public BitSetIndex() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public BitSetIndexModel(String type) &#123;</span><br><span class="line">		this.type = type;</span><br><span class="line">		map = new ConcurrentHashMap&lt;String, Integer&gt;();</span><br><span class="line">		list = new ArrayList&lt;String&gt;();</span><br><span class="line">		bsList = new ArrayList&lt;BitSet&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public String getType() &#123;</span><br><span class="line">		return type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setType(String type) &#123;</span><br><span class="line">		this.type = type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Map&lt;String, Integer&gt; getMap() &#123;</span><br><span class="line">		return map;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setMap(ConcurrentHashMap&lt;String, Integer&gt; map) &#123;</span><br><span class="line">		this.map = map;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public List&lt;String&gt; getList() &#123;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setList(List&lt;String&gt; list) &#123;</span><br><span class="line">		this.list = list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public List&lt;BitSet&gt; getBsList() &#123;</span><br><span class="line">		return bsList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setBsList(List&lt;BitSet&gt; bsList) &#123;</span><br><span class="line">		this.bsList = bsList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 *</span><br><span class="line">	 * @param str</span><br><span class="line">	 * @param i</span><br><span class="line">	 */</span><br><span class="line">	public void createIndex(String str, int i) &#123;</span><br><span class="line">		BitSet bitset = null;</span><br><span class="line">		//获取‘str’对应的bitset在bsList中的下标</span><br><span class="line">		Integer index = this.getMap().get(str);</span><br><span class="line">		if (index != null) &#123;</span><br><span class="line">			bitset = this.getBsList().get(index);</span><br><span class="line">			if (bitset == null) &#123;</span><br><span class="line">				bitset = new BitSet();</span><br><span class="line">				this.getBsList().add(index, bitset);</span><br><span class="line">			&#125;</span><br><span class="line">			bitset.set(i, true);// 将str对应的位置为true,true可省略</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			bitset = new BitSet();</span><br><span class="line">			List&lt;String&gt; list = this.getList();</span><br><span class="line">			list.add(str);</span><br><span class="line">			index = list.size() - 1;</span><br><span class="line">			bitset.set(i, true);</span><br><span class="line">			this.getBsList().add(bitset);</span><br><span class="line">			this.getMap().put(str, index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 从entity里拿出符合条件的bitset</span><br><span class="line">	 *</span><br><span class="line">	 * @param str</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public BitSet get(String str) &#123;</span><br><span class="line">		BitSet bitset = null;</span><br><span class="line">		str = str.toLowerCase();</span><br><span class="line">		Integer index = this.getMap().get(str);</span><br><span class="line"></span><br><span class="line">		if (index != null) &#123;</span><br><span class="line">			bitset = this.getBsList().get(index);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			bitset = new BitSet();</span><br><span class="line">		&#125;</span><br><span class="line">		return bitset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * bitset的与运算</span><br><span class="line">	 *</span><br><span class="line">	 * @param str</span><br><span class="line">	 * @param bitset</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public BitSet and(String str, BitSet bitset) &#123;</span><br><span class="line">		if (str != null) &#123;</span><br><span class="line">			str = str.toLowerCase();</span><br><span class="line">			if (bitset != null) &#123;</span><br><span class="line">				bitset.and(get(str));</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				bitset = new BitSet();</span><br><span class="line">				bitset.or(get(str));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return bitset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * bitset的或运算</span><br><span class="line">	 *</span><br><span class="line">	 * @param str</span><br><span class="line">	 * @param bitset</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public BitSet or(String str, BitSet bitset) &#123;</span><br><span class="line">		if (str != null) &#123;</span><br><span class="line">			str = str.toLowerCase();</span><br><span class="line">			if (bitset != null) &#123;</span><br><span class="line">				bitset.or(get(str));</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				bitset = new BitSet();</span><br><span class="line">				bitset.or(get(str));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return bitset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 获取bitset值为true的 即 把 bitset翻译为list的索引</span><br><span class="line">	 *</span><br><span class="line">	 * @param bitset</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static List&lt;Integer&gt; getRealIndexs(BitSet bitset) &#123;</span><br><span class="line">		List&lt;Integer&gt; indexs = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		if (bitset != null) &#123;</span><br><span class="line">			int i = bitset.nextSetBit(0);</span><br><span class="line">			if (i != -1) &#123;</span><br><span class="line">				indexs.add(i);</span><br><span class="line">				for (i = bitset.nextSetBit(i + 1); i &gt;= 0; i = bitset.nextSetBit(i + 1)) &#123;</span><br><span class="line">					int endOfRun = bitset.nextClearBit(i);</span><br><span class="line">					do &#123;</span><br><span class="line">						indexs.add(i);</span><br><span class="line">					&#125; while (++i &lt; endOfRun);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return indexs;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为每一个user对象创建address,gender,age维度索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserIndexStore &#123;</span><br><span class="line"></span><br><span class="line">	private static final String ADDRESS = &quot;address&quot;;</span><br><span class="line">	private static final String GENDER = &quot;gender&quot;;</span><br><span class="line">	private static final String AGE = &quot;age&quot;;</span><br><span class="line">	private BitSetIndexModel address;</span><br><span class="line">	private BitSetIndexModel gender;</span><br><span class="line">	private BitSetIndexModel age;</span><br><span class="line">	private ConcurrentHashMap&lt;Integer, User&gt; userMap;//存储所有的user数据</span><br><span class="line">        private ConcurrentHashMap&lt;String, Integer&gt; nameIndexMap;//name和index映射</span><br><span class="line"></span><br><span class="line">	public static final UserIndexStore INSTANCE = getInstance();</span><br><span class="line"></span><br><span class="line">	private UserIndexStore() &#123;</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static UserIndexStore getInstance() &#123;</span><br><span class="line">		return UserIndexStoreHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static class UserIndexStoreHolder &#123;</span><br><span class="line">		private static UserIndexStore instance = new UserIndexStore();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void init() &#123;</span><br><span class="line">		this.address = new BitSetIndexModel(ADDRESS);</span><br><span class="line">		this.gender = new BitSetIndexModel(GENDER);</span><br><span class="line">		this.age = new BitSetIndexModel(AGE);</span><br><span class="line">		userMap = new ConcurrentHashMap&lt;Integer, User&gt;();</span><br><span class="line">                nameIndexMap =  new ConcurrentHashMap&lt;String, Integer&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 构建索引</span><br><span class="line">	 * @param users </span><br><span class="line">	 */</span><br><span class="line">	public void createIndex(List&lt;User&gt; users) &#123;</span><br><span class="line">		if (users != null &amp;&amp; users.size() &gt; 0) &#123;</span><br><span class="line">			for (int index = 0; index &lt; users.size(); index++) &#123;</span><br><span class="line">				User user = users.get(index);</span><br><span class="line">				createIndex(user, index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void createIndex(User user, int index) &#123;</span><br><span class="line">		getAddress().update(user.getAddress(), index);</span><br><span class="line">		getGender().update(user.getGender(), index);</span><br><span class="line">		getAge().update(user.getAge(), index);</span><br><span class="line">		this.userMap.put(index, user);</span><br><span class="line">		this.nameIndexMap.put(user.getName(), index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public BitSet query(String address, String gender, String age) &#123;</span><br><span class="line">		BitSet bitset = null;</span><br><span class="line">		bitset = getAddress().and(address, bitset);</span><br><span class="line">		bitset = getGender().and(gender, bitset);</span><br><span class="line">		bitset = getAge().and(age, bitset);</span><br><span class="line">		return bitset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public User findUser(Integer index) &#123;</span><br><span class="line">		User user = this.userMap.get(index);</span><br><span class="line">		if (user != null) &#123;</span><br><span class="line">			return user.clone();//可能会对user做修改操作,要保证内存原始数据不变</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public BitSetIndexModel getAddress() &#123;</span><br><span class="line">		return address;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setAddress(BitSetIndexModel address) &#123;</span><br><span class="line">		this.address = address;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public BitSetIndexModel getGender() &#123;</span><br><span class="line">		return gender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setGender(BitSetIndexModel gender) &#123;</span><br><span class="line">		this.gender = gender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public BitSetIndexModel getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setAge(BitSetIndexModel age) &#123;</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-测试bitset"><a href="#3-测试bitset" class="headerlink" title="3.测试bitset"></a>3.测试bitset</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BitSetTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;User&gt; users = buildData();</span><br><span class="line">		UserIndexStore.getInstance().createIndex(users);</span><br><span class="line">		ExecutorService executorService = Executors.newFixedThreadPool(20);</span><br><span class="line">		int num = 2000;</span><br><span class="line">		long begin1 = System.currentTimeMillis();</span><br><span class="line">		for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">			Runnable syncRunnable = new Runnable() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					List&lt;Integer&gt; indexs = BitSetIndexModel.getRealIndexs(UserIndexStore.getInstance().query(&quot;北京&quot;, &quot;girl&quot;, &quot;18&quot;));</span><br><span class="line">					for (Integer index : indexs) &#123;</span><br><span class="line">						UserIndexStore.getInstance().findUser(index);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			executorService.execute(syncRunnable);</span><br><span class="line">		&#125;</span><br><span class="line">		executorService.shutdown();</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (executorService.awaitTermination(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">					System.out.println(&quot;单次查询时间为：&quot; + (System.currentTimeMillis() - begin1) / num + &quot;ms&quot;);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static List&lt;User&gt; buildData() &#123;</span><br><span class="line">		String[] addresss = &#123; &quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot; &#125;;</span><br><span class="line">		String[] ages = &#123; &quot;16&quot;, &quot;17&quot;, &quot;18&quot; &#125;;</span><br><span class="line">		List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">		for (int i = 0; i &lt; 200000; i++) &#123;</span><br><span class="line">			User user = new User();</span><br><span class="line">			user.setName(&quot;name&quot; + i);</span><br><span class="line">			int rand = ThreadLocalRandom.current().nextInt(3);</span><br><span class="line">			user.setAddress(addresss[ThreadLocalRandom.current().nextInt(3)]);</span><br><span class="line">			user.setGender((rand &amp; 1) == 0 ? &quot;girl&quot; : &quot;boy&quot;);</span><br><span class="line">			user.setAge(ages[ThreadLocalRandom.current().nextInt(3)]);</span><br><span class="line">			users.add(user);</span><br><span class="line">		&#125;</span><br><span class="line">		return users;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果(查询2w次)：<br>数据量（users.size()） | 并发数 | 平均查询时间<br>—|—|—<br>20w | 10 | 1ms<br>50w | 20 | 3ms<br>100w| 50 | 9ms</p>
<blockquote>
<p>测试机为thinkpad x240 i5 8g内存</p>
</blockquote>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h5><p>==优点==：<br>通过测试发现随着数据量的增大和并发数的提高，平均耗时并没有明显升高，并且响应时间都在10ms以内</p>
<p>==缺点==：</p>
<ol>
<li>不适合数据量太大的情况,因为需要把数据全部加载进内存</li>
<li>不适合复杂查询</li>
<li>不适合对name,id等唯一值做查询<h5 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h5></li>
</ol>
<p><strong>因为我们的查询业务比较简单，唯一的要求是速度，并且数据量也不大，每张表的数据量都不超过100w，所以使用这种方式比较合适。<br>在本篇文章中只谈到了如何创建索引，以及最基本的查询，在下一篇中我会继续说明如何更新索引，以及一些复杂查询，比如&lt;,&gt;,between and。</strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
